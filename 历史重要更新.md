#### 历史重要更新

#### 重构日志组件，业务逻辑不依赖具体的日志组件 2020年2月10日
**game-log-api模块的core包**的5个接口定义了日志发布和消费的抽象流程，它与任何日志框架/组件都无关，使得我们可以去除对具体日志组件的依赖。  
使得业务逻辑可以专注于自己的业务，而不必考虑大量细节。
(数据库也是细节，要实现业务逻辑不依赖数据存储方式的话，必须对数据存取建立很好的抽象，这个难度很高，还未准备好)

#### 更友好的异步API支持(MethodHandle + Client) 2020年2月8日
经过几版迭代，提供了更好的异步API支持-见 **MethodHandle**。  
修改了旧版必须先设置回调再进行调用的反人类设计（之前其实也像现在这样实现过，不过想减少对象创建，又改回去了）。  
现在的异步架构设计为**MethodHandle** + **Client**方式，算是较大的改进。  
注意：需要重新安装注解处理器！

#### EventBus优化 添加泛型事件支持 2020年1月19日
去除之前 context + event的实现，新增**GenericEvent**实现，其实是将上下文对象和事件合并为一个对象。  
示例见**SubscriberExample**，本版本需要重新安装注解处理器，否则无效。

#### 为javaBean和自定义枚举生成对应的编解码辅助类 2020年1月14日13:11:45
详情请查看**SerializableClass**类文档，大多数情况下课代替反射，极大提升编解码性能(30%左右)。  
对于普通的JavaBean，会为其生成编解码工具类，而如果有特殊限制的类(eg: 不可变对象)，则会使用反射进行编解码，并不强制必须实现为JavaBean。 
对于自定义枚举，也会为其生成编解码工具类。  
注意：需要重新安装注解处理器！

#### 基于Instrumentation的热更新机制(初版) 2020年1月12日
相对于其它热更新机制(自定义ClassLoader，继承等)，基于Instrumentation的热更新是最方便的。开发方便，执行热更也方便。
修复一般性的bug完全足够。

#### Rpc转发支持 2020年1月4日
RpcCall可以作为普通参数进行传递，可以通关代理工具类获得RpcCall对象，对象保留了要调用的方法信息，然后交给中间层执行真正的调用。  
完善注解处理器的泛型处理信息，需要重新生成注解处理器，否则编译报错。
参考实现：**ICenterRouterMgr**

#### EventBus优化 2019年12月18日(已删除)
EventBus支持抛事件时同时抛出事件对应的上下文信息。  
EventHandler变为双参数接口，可以获得抛出事件时关联的上下文信息。

#### redis支持 2019年12月12日
封装jedis原生的pipeline，提供更好的异步api，支持回调。  
个人感觉一个RedisEventLoop足以应付游戏内的读写需求了。

#### EventBus事件监听优化 2019年12月7日
Subscribe除了订阅函数参数对应的子类型以外，还可以通过types属性指定更多的子类型，仍然由注解处理器注册订阅的类型。
示例见**SubscriberExample**，本版本需要重新安装注解处理器，否则无效。

#### 基于Kafka的日志组件 2019年11月28日
简单的写了一下游戏埋点日志，有些设计来源于之前做的项目，但又有很大的不同，需要安装kafka。  
> 游戏逻辑线程将日志提交给日志线程，日志线程将数据发送到kafka服务器。  
> 消费日志的话，讲道理是单独的进程，而不是游戏服务器。

#### JAVA-ZSET 2019年11月7日
这两天切换了脑袋的上下文，研究了一下redis的zset实现，实现了一个java版的，可用于游戏内的排行榜和拍卖行。  
Q: 为什么需要？  
> 1. 游戏内的排行榜需要信息很多时候不能简单的表示为一个数字。  
> 2. 对逆序排行榜不友好。  
> 3. 数据存储在redis中，不能真实时，交互也不是很方便。  
> 4. 目前手里没有什么比较好的做排行榜的组件。  

#### 网关服节点发现 2019年11月3日
添加网关服组件，实现节点发现相关。最近代码写太多了，写两天翻译去。

#### 场景服架构调整 2019年10月31日
删除纯粹的单服场景服，即每个场景服即提供单服玩法，也提供跨服玩法。该架构有以下优势：  
1. 可以实现更好的负载均衡和高可用。  
2. 可以支持更多的跨服互动。  
PS: 有点伪世界服架构的感觉。

#### 使用EventBus重写了NetEventLoop和NetEventLoop中的接口2019年10月27日
使用EventBus有好有坏，我也是纠结了很久才决定改造的。  
EventBus对于解耦和接口演进很有用，对于性能肯定是会拖慢一点的，另外也会造成可读性的下降。  
Q: 有时候做选择的时候会纠结，为什么纠结呢？  
A: 当不太清楚即将的改动对性能到底有多大影响时就会纠结。。。

#### 重新实现了消息确认机制，支持限流 2019/10/18
重新实现了消息确认机制，不过需要翻译**OuterConnectorHandler**为客户端对应的语言。  
新版本特性：
1. 使用了累积确认机制，可以更快的对数据包进行确认。  
2. 使用了漏桶算法，可以有效的控制发包速率，消息重发也更加安全(有效控制了重发包时的数量)。  

Q: 为什么需要消息确认机制？  
A: 消息确认机制主要针对手机用户的。移动端网络不稳定，很容易产生丢包，socket断开的情况，如果socket断开就使得玩家必须重新登录(包括快速登录)
这个体验是非常差的。消息确认机制可以使得玩家感觉只是产生了延迟。

#### 单向消息/Rpc支持转发，中间节点消除序列化反序列化操作 2019年10月11日
请注意查看**LazySerializable**和PreDeserializable**注解。  
Q: 它主要解决什么问题？  
A: 逻辑服务器通过网关向玩家发送数据，玩家向逻辑服务器发送数据时，在网关服消除冗余的编解码操作。

#### 恢复NetEventLoop多线程模型 2019年10月05日 - 真香
通过sessionId实现粘性session，使得同一个sessionId的数据总是由同一个NetEventLoop来处理，从而保证数据安全性，即使更换channel，仍然支持消息确认机制。

#### 通过SessionPipeline提供功能插拔特性 2019年10月02日
1. 之前的SessionManager代码组织较为混乱，扩展功能较为困难，一直在想办法解决这个问题，这版本引入了类似Netty的ChannelPipeline的SessionPipeline。
通过handler的方式实现插拔功能，以消除重复代码和提升扩展性。  
如：是否使用消息确认机制通过增删handler来实现，内网通信可以不开启，这样内网通信传输的数据量就会减少许多，走到的代码也会少很多。   
又如：服务器与玩家之间是没有rpc的，因此与玩家的session之间也不会有rpc相关的逻辑。  
当然，这是有代价的，代价就是JVM内部传输数据速度变慢，因为有大量的空方法需要执行和冗余判断 - 这些在JVM内部通信之间占的比重还挺大。  
2. **该版本需要重新生成注解处理器**（文件重新归档导致）。
3. 还有很多尚未完成的地方，只是都可以重新运行起来了，还需要继续迭代。

#### 正确的实现DisruptorEventLoop 2019年9月17日
之前实现的Disruptor跑偏了，这两日突然想明白了，进行了正确的实现，相对于**SingleThreadEventLoop**，内存利用率更高，性能也更好，对于追求极致性能的EventLoop提供了很好的框架。  
顺便基于DisruptorEventLoop重写了GameEventLoop。  
如果你想要学习**Disruptor**，那么推荐你看我详细注释过的源码[disruptor-translation](https://github.com/hl845740757/disruptor-translation)  
如果你想学习**Netty**的线程模型，你可以看看我注释过的源码[netty-translation](https://github.com/hl845740757/netty-translation)，netty并没有全部注释，不过并发包是基本是完整注释的。  

#### 修改sync语义 2019年9月13日
同步rpc调用不再插队，而是刷新缓冲区，和其它消息之间也满足先发的先到，后发的后到。

#### LocalSession 2019年9月10日
为JVM内部线程提供session支持，JVM内通信和跨进程之间的通信有相同的API。你可以通过**NetContext**轻松的连接到另一个线程，其通信开销远远小于socket。  
**LocalSessionExample**是一个测试用例。

#### 线程模型调整 2019年9月06日
一个GameEventLoop只承载单个World，具有更简单的编程模型，且更加安全。

#### 注解处理器优化 2019-08-26
注解处理器不再依赖utils和net模块，而是utils依赖auto模块，这样utils和net模块也可以使用自己定义的注解了。

#### EventBus 2019-08-24
1. 在utils包下有一套基础的EventBus实现。
2. 订阅方法代码自动生成。
3. 在example目录下同样提供了一个测试用例，编译后可运行。

#### Rpc优化 2019-08-21
1. Rpc调用更加标准化。
2. 编解码更快，功能支持更强，请查看**SerializableClass**和**SerializableField**注解。
3. RpcService代码自动生成，你必须将game-auto打为jar包才可以使用代码生成工具(注解处理器必须是jar包形式)，请确保所有模块都启用了注解处理器。
4. 在net模块下，example下有几个测试用例，其中： **ExampleRpcClientLoop**是一个Rpc客户端，**ExampleRpcService**是一个Rpc服务，编译后可直接运行。
5. 还有一些别的测试用例，并没有使用自动生成的代码，用法很原始，更贴近底层。

#### 数据库引入-MongoDB  
* MongoDB是NOSQL数据库，个人感觉其对程序员非常友好，而且数据扩展容易（很适合游戏），性能也好。

#### 视野管理已加入(9宫格)
* 游戏视野管理为9宫格。

#### 寻路算法已加入(Jump Point Search)
1. JPS寻路算法是对A*算法的一个优化，不算很复杂，适合多数的MMO游戏。
2. 图形化测试用例：JPSTest.java  

#### 游戏的玩法架构：  
1. 游戏世界划分为多个区域，每个World（频道）承载一个或多个区域，支持跨运营平台，跨服玩法。  
2. 在game-core包的doc文件夹下可以看见服务器架构、场景区域划分等图。  
3. 待完善的是负载均衡和宕机恢复。
