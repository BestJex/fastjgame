### fastjgame
fastjgame 为 fast java game framework的缩写，如名字一样，该项目的目标是一个高性能，高稳定性的游戏架构。  
1. 它将是一个分布式多线程架构，它有着良好的多线程模型。  
2. 高性能从网络层开始： 支持异步消息，异步rpc调用，同步rpc调用，以及良好的接口。 
3. IO框架为Netty,HttpClient为OkHttp3; 防闪断/自动断线重连，支持websocket和tcp同时接入。 
4. 支持google protoBuf，json以及自定义消息序列化方式。 支持自定义消息映射;  
5. 分布式协调框架：zookeeper 作为配置中心，节点发现，以及不时的分布式锁需要  
6. NoSQL数据库： mongodb 习惯了mongodb回不去MySQL
7. 代码自动生成: RpcService、Subscribe相应代码自动生成。代码生成一时爽，一直生成一直爽。

### 全新版本 2019-08-05
2019年8月5日 迎来了fastjgame的全新版本，线程模型大改，底层通信重写，网络层与逻辑层独立。
1. 更强大的网络层，异步rpc调用，同步rpc调用使用起来很简单。旧版本的session管理器真的很难用。
2. 线程模型改动，由最开始的单线程模型变为多线程模型，而且是变成模型很友好的多线程模型(并发包主要参考了Netty的思路)。
3. 支持一个进程启动所有类型服务器！在game-start模块中，**StartUp**类是一个测试用例。可以启动所有服务器
   （你需要安装zookeeper，在doc文件夹下有我zookeeper导出的配置）。

### Rpc优化 2019-08-21
1. Rpc调用更加标准化。
2. 编解码更快，功能支持更强，请查看**SerializableClass**和**SerializableField**注解。
3. RpcService代码自动生成，你必须将game-auto打为jar包才可以使用代码生成工具(注解处理器必须是jar包形式)，请确保所有模块都启用了注解处理器。
4. 在net模块下，example下有几个测试用例，其中： **ExampleRpcClientLoop**是一个Rpc客户端，**ExampleRpcService**是一个Rpc服务，编译后可直接运行。
5. 还有一些别的测试用例，并没有使用自动生成的代码，用法很原始，更贴近底层。

### EventBus 2019-08-24
1. 在utils包下有一套基础的EventBus实现。
2. 订阅方法代码自动生成。
3. 在example目录下同样提供了一个测试用例，编译后可运行。

### 注解处理器优化 2019-08-26
注解处理器不再依赖utils和net模块，而是utils依赖auto模块，这样utils和net模块也可以使用自己定义的注解了。

### 如何使用注解处理器？
1. 将game-auto添加到project-structure
2. install game-auto 到本地仓库
3. 将game-auto从项目project-structure中移除，注解处理器必须以jar包形式工作。
4. 在game-parent下clean，再compile，可消除缺少类文件的报错。

### 编译出现找不到符号问题怎么解决？
1. 确保注解处理器已install到本地仓库。
2. clean
3. compile

### 高性能从网络层开始  
1. IO框架为Netty,HttpClient为OkHttp3;   
2. 支持断线重连/防闪断，支持websocket和tcp同时接入。  
3. 支持自定义协议解析-实现**ProtocolCodec**。
4. 有基于protoBuf的协议传输，也有基于json的协议传输，都是ProtocolCodec的实现类。
5. 实现了一套完整的rpc，支持异步消息，异步rpc调用，同步rpc调用。
6. 网络层多线程模型(8/5日改动)

### 游戏服务器的节点发现以完成：
* 基于zookeeper实现，同时zookeeper作为配置中心，以及分布式锁.  
  zookeeper的配置在**game-start**的doc文件夹下可以找到。
  如果你想使用中文配置zkui，请使用我修正后的[zkui](https://github.com/hl845740757/zkui)，内部有可运行jar包，你也可以自己编译一遍。

### 数据库引入-MongoDB  
* MongoDB是NOSQL数据库，个人感觉其对程序员非常友好，而且数据扩展容易，性能也好。

***
### 多线程框架的好与坏
关于多线程的游戏服务器架构，不同公司，不同项目的设计很可能都是不一样的，这很正常。
每个人的技术栈可能不一样，编程思想也有很大差别，游戏需求也不一样，
此外多线程的设计往往涉及很多取舍，每个人都有自己的取舍，因此诞生出各种各样的框架。   

一个框架的好坏不能只看某个方面，没有完美的框架，一个框架最重要的是适合自己。
虽然存在众多框架，但不一定能找到一个适合自己的框架，甚至找到具有参考价值的都不容易。  

我可能会表露我不喜欢什么样的设计，这不代表我的设计就一定比它好！  
记住：**取舍**！

#### 我坚持什么？
我不会追求极致的性能，我会尽量保持编程模型的简单性，同时尽量地拓展性能。  

#### 为什么？
编程模型如果不够简单，对于有经验的开发人员来说,容易陷入解决各种各样的复杂问题中，花在这上面的时间很可能超过他们做真正有意义的事情的时间，开发效率太低；  
而对于普通程序员，甚至可能都不知道问题的存在，导致无数的潜在bug！  
总的来说：复杂的编程模型，导致编程效率较低，且正确性很难保证！  

举个栗子：  
纯异步编程模型，当方法调用链过长的时候是个灾难，当提供回调机制的时候，更加恐怖，它可能产生内存泄漏，信号丢失，以及其它逻辑错误。  
建议：使用回调机制时，不要乱传递数据（不要乱捕获数据）。  

总的来说：  
    复杂的编程模型对团队的成员提出了更高的要求，只有团队成员都足够优秀的时候，才能保证正确性和开发效率，它可能是为了极致的性能，也可能是为了其它。  
而我往往对团队的成员并不充满信心，一个团队良莠不齐很正常，多数人是普通人，优秀的人少。因此我选择舍弃一部分性能，换得更简单的编程模型，以保证开发效率和正确性。
更简单的编程模型，更容易保证正确性，以及程序的健壮性。

### 哪些模块适合多线程化
游戏架构的各个模块其实都可以多线程化，但是最重要的是场景服多线程化，场景服更容易遇见性能瓶颈。
至于其它模块，如果没有太大压力，单线程就足够了。

#### 如何多线程化？
对于这个问题，其实有好几种方式，如：
1. 按业务逻辑划分线程：AOI管理，AI管理，战斗，其它玩法。 
    1. 逻辑拆分的太细，涉及大量的共享数据，编程复杂度极高（大量多线程代码或大量异步代码），很难保证正确性，开发效率也很有问题。
    2. 我觉得这样设计的人对多线程技术怕是有误解。线程的任务之间有过多的依赖和数据交互，是不适合多线程化的。
    3. 极其不推荐，极其不推荐，极其不推荐！！！
    
2. 按区域划分线程：对MMO游戏来说，将一个进程要负责的地图划分为多个区域，一个区域的逻辑在一个线程。区域的划分方式不一定与游戏地图一致：
    1. eg：按照游戏地图划分，比如 1-30级的地图在一个线程；31-50级的地图在一个线程... 玩家只有在同一个区域时，数据才是可直接使用的。
    2. 拿交易系统举例，只有玩家进入同一个区域下时，这个操作才是允许的。
    3. 不推荐！因为他缺少清晰的编程边界！它的编程边界不符合人的正常思维，编程就容易出问题！
    
3. 按单个场景划分线程：对MMO游戏来说，一个场景内的所有逻辑在一个线程内（而不是一个线程一个场景）。对于开房间类型的游戏，一个房间内的所有逻辑在一个线程。
    1. 这样的划分方式是合理的。个人认为最小单元不能小于一个场景，当一个场景下的数据是多线程化的时候，复杂度极高。
    2. 这种方式，只有当玩家在同一个场景下时，数据才是直接可用的，可能会限制部分功能实现。
    3. 拿交易系统举例，只有玩家在同一个场景下时，这个操作才是允许的。
    4. 它对程序的性能是最友好的，但是对玩家体验是不太好的。
    5. 它有着较为清晰的编程边界，但是编程仍然较为困难，因为游戏跨场景的逻辑还是很多的！这样的拆分方式还是有点细！
    6. 推荐度

4. 按场景类型划分线程：对MMO游戏来说，地图一般有主城、副本、活动地图等，每一个类型在一个线程。
    1. 这种划分方式也是合理的，它降低了一部分性能，一定程度简化了编程模型，也提高了玩家的体验。
    2. 这种方式，只有当玩家在同类型的场景下时，数据才是直接可用的，可能会限制部分功能实现（限制的会少一点）。    
    3. 拿交易系统举例，只有玩家在同类型场景下时，这个操作才是允许的。
    4. 它能提升一定的性能，对玩家的体验也有一定的提升。
    5. 它有着较为清晰的编程边界，但是扩展很难。

5. 一个进程内的线程之间是独立同构的，每个线程都拥有完整的游戏逻辑（可以看做分线，不同的分线可以有不同的玩法）。
    1. 这样的划分方式也有它的好处，每一个线程是独立且同构的，编程模型简单（一个线程对应一个World）。
    2. 这样的划分方式，当玩家在同一个world的时候，数据就是可用的。
    3. 拿交易系统举例，只有玩家进入同一个workd时，这个操作才是允许的。
    4. 它能提升较多的性能，且在多线程模型中对玩家的体验是最好的。
    5. 它有着清晰的编程边界，且很容易水平扩展，此外它可以很容易的退回到单线程模型，也可以把想要优化的部分提取到多线程模块中。
    6. 我是实现便是这种，可进可退。
    7. 如果游戏允许（显式的或潜在的）分频道或分线，那么我极力推荐你使用这种方式！

#### 总的来说
1. 划分的太细时：当游戏逻辑较复杂时，各个小的模块之间涉及大量的数据共享。
要解决这种问题，要么加锁处理竞争，要么使用消息进行通信（异步化），无论哪一种都会大大加重开发人员的负担。
这也是我极不推荐第一种划分方式的原因。
2. 划分的太粗糙时：每个线程可能存在不必要的任务，造成性能浪费。性能无法最大化。
我的建议是，可以适当的粗糙一点，而不要追求尽量的小。
3. 选择必须符合游戏需求，不能强制让游戏按照架构设计！需求决定架构，而不是架构决定需求。
4. 我不推荐纯异步的编程模型(使用消息交互)，也不推荐纯粹的多线程编程模型，推荐在确定边界内使用同步编程。

#### 多线程化需要注意的一些问题
1. 缓存。在多线程下慎用全局缓存（静态变量），如果要使用缓存，建议优先考虑ThreadLocal。
2. 为了减少开发人员的错误，建议单个线程下只能获取到自己能用的数据。这要求数据存储的位置要精心设计。
3. 想到再说...
***

#### 视野管理已加入(9宫格)
* 游戏视野管理为9宫格。

#### 寻路算法已加入(Jump Point Search)
1. JPS寻路算法是对A*算法的一个优化，不算很复杂，适合多数的MMO游戏。
2. 图形化测试用例：JPSTest.java  

#### 游戏的玩法架构：  
1. 游戏世界划分为多个区域，每个World（频道）承载一个或多个区域，支持跨运营平台，跨服玩法。  
2. 在game-core包的doc文件夹下可以看见服务器架构、场景区域划分等图。  
3. 待完善的是负载均衡和宕机恢复。

#### 说下自己为什么开源
1. 开源的高质量的源码太少，大多质量都太差，代码混乱，编程模型复杂。
2. 我个人非常看重游戏的创意，而这些创意很多时候在中小型游戏公司产生，而往往缺乏技术支撑的却是他们。

#### 更新问题 
+ 由于要上班的，而且没有确切的需求，导致了很多东西无法继续进行，所以架构可能会不停的优化更新，但是业务逻辑可能进展很慢。

(Markdown语法不是很熟悉，排版什么的后期有空再优化~)
