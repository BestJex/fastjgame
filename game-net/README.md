### fastjgame-net

fastjgame-net模块独立，一个高性能的可扩展底层通信框架。支持断线重连(防闪断)，负载均衡，使用简单。提供双向的消息通知，异步rpc调用，同步rpc调用。

### 本模块到底提没提供RPC?
   严格的说，本模块提供了对RPC的支持，但是如何解析RPC包的内容，并调用到指定方法，这个是可以自定义的，没有限定rpc的解析方式！  
   本模块提供了一种rpc的实现，包括对应的注解、注解处理器。但这不限制你添加自己的rpc实现。你可以从**RpcCall**和**RpcBuilder**入手。
   
### Rpc到底理解会好点呢？
   我在实现rpc的时候，进行抽象的时候，其实走了不少弯路，后来才发现，其实把rpc调用当做多线程调用就好了，什么时候应该返回值，什么时候不需要返回值？  
   其实**单向通知**或**不关心结果的rpc调用**就相当于**Runnable**，而**需要结果的rpc调用**，相当于**Callable**.
   
### 消息分类
1. 异步消息：单向消息、异步Rpc请求、异步Rpc调用的结果
2. 同步消息：同步rpc请求、同步Rpc调用的结果

### 消息顺序问题(极其重要)
 网络层提供以下保证：
 1. 任意两个异步消息之间，都满足先发送的先到。
 
 2. 任意两个同步消息之间，都满足先发送的先到。

 3. 任意两个异步消息之间，都满足先接收到的先提交给应用层。 --- (应用层可以打乱处理顺序)
 
 4. 任意两个同步消息之间，都满足先接收到的先提交给应用层。 --- (应用层无法打乱处理顺序)

### 常见问题 
 Q: 为什么不提供同步调用 与 异步调用 之间的顺序保证？  
 A: 基于这样的考虑：同步调用表示一种更迫切的需求，期望更快的处理，更快的返回，而异步调用没有这样的语义。
 
 Q: 异步消息顺序中，应用层可以打乱处理顺序是什么意思？不是先接收到的先提交给应用层了吗？  
 A: 异步Rpc调用提供了RpcFuture，既可以在RpcFuture上添加回调，也可以在RpcFuture上阻塞到完成。如果在RpcFuture上阻塞到完成，那么表示了应用层选择了**先处理**
 该RpcFuture对应的结果，然后再处理其它异步消息。这种情况，有时候是无害的，有时候是有害的，**一定要清楚阻塞调用带来的时序问题，否则不要轻易的进行阻塞！**
 使用回调机制不会打乱处理顺序。
    
 Q: 同步消息顺序中，应用层无法处理顺序又是什么意思？  
 A: 因为应用层一次只能发起一次同步调用啊~
 
 Q: {@link RpcFuture#get()}{@link RpcFuture#await()} 阻塞到结果返回是同步调用吗？  
 A: 不是！！！ {@link #rpc(Object)}是异步调用！即使你可以阻塞到结果返回，它与{@link #syncRpc(Object)}在传输的时候有本质上的区别。

 Q: 能举个说明打乱异步消息顺序可能有害的栗子吗？  
 A: 我向对方发起了一个查询余额的请求，对方在接收到该请求之前，对方“先”主动告诉我剩余10块钱(单向消息或Rpc请求),
 “然后”接收到查询余额的Rpc请求，这时返回剩余8块钱。对方是先告诉你有10块钱，然后再告诉你剩余8块钱的，但是我阻塞到rpc完成，
 先处理了剩余8块钱的消息，然后处理了剩余10块钱的消息。导致：对方认为你还有8块钱，而你认为你还有10块钱！
    
 Q: 那无害的栗子呢？  
 A: 我同时发起加载图片与加载文字的Rpc请求，然后在任意一个Rpc请求上阻塞到完成，对于结果并没有影响。

### 注意死锁问题
   如果一个会话的双方都使用同步rpc调用，虽然有超时时间，但是也很危险，会大大增加超时失败的几率，尽量只有一方使用同步rpc调用，双向的异步rpc还是可以的。  
   此外也尽量少调用RpcFuture上的get，await方法，建议使用回调，也会增加rpc超时的几率。 

### 应用层与NetEventLoop之间的关系
![image](https://github.com/hl845740757/fastjgame-net/blob/master/src/doc/%E5%BA%94%E7%94%A8%E5%B1%82%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92.png)

### 数据包传输过程
![image](https://github.com/hl845740757/fastjgame-net/blob/master/src/doc/%E6%95%B0%E6%8D%AE%E5%8C%85%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png)

### rpc注解处理器
    请查看项目总目录下的readMe。

### example下的测试用例
   Rpc测试用例： 有**ExampleRpcService** 和 **ExampleRpcClientLoop**。
   贴近底层的示例：有**EchoServerLoop**和**EchoLCientLoop**和**PipelineEchoClientLoop**，可以直接启动。 
### Bugs
   码多必失，如果发现bug，欢迎提出。
