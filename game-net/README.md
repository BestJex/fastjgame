### fastjgame-net

fastjgame-net模块独立，一个高性能的可扩展底层通信框架。支持断线重连(防闪断)，负载均衡，使用简单。提供双向的消息通知，异步rpc调用，同步rpc调用。

### 本模块到底提没提供RPC?
   严格的说，本模块提供了对RPC的支持，但是如何解析RPC包的内容，并调用到指定方法，这个是可以自定义的，没有限定rpc的解析方式！  
   本模块提供了一种rpc的实现，包括对应的注解、注解处理器。但这不限制你添加自己的rpc实现。你可以从**RpcCall**和**RpcBuilder**入手。
   
### Rpc到底理解会好点呢？
   我在实现rpc的时候，进行抽象的时候，其实走了不少弯路，后来才发现，其实把rpc调用当做多线程调用就好了，什么时候应该返回值，什么时候不需要返回值？  
   其实**单向通知**或**不关心结果的rpc调用**就相当于**Runnable**，而**需要结果的rpc调用**，相当于**Callable**.
   
### 消息分类
1. 异步消息：单向消息、异步Rpc请求、异步Rpc调用的结果
2. 同步消息：同步rpc请求、同步Rpc调用的结果

### 消息顺序问题(极其重要)
 网络层提供以下保证：
 1. 任意两个异步消息之间，都满足先发送的先到。
 
 2. 任意两个同步消息之间，都满足先发送的先到。

 3. 任意两个异步消息之间，都满足先接收到的先提交给应用层。
 
 4. 任意两个同步消息之间，都满足先接收到的先提交给应用层。

### 常见问题 
 Q: 为什么不提供同步调用 与 异步调用 之间的顺序保证？  
 A: 基于这样的考虑：同步调用表示一种更迫切的需求，期望更快的处理，更快的返回，而异步调用没有这样的语义。
 
### 注意死锁问题
   如果一个会话的双方都使用同步rpc调用，虽然有超时时间，但是也很危险，会大大增加超时失败的几率，尽量只有一方使用同步rpc调用，双向的异步rpc还是可以的。  
   此外也尽量少调用RpcFuture上的get，await方法，建议使用回调，也会增加rpc超时的几率。 

### 应用层与NetEventLoop之间的关系
![image](https://github.com/hl845740757/fastjgame-net/blob/master/src/doc/%E5%BA%94%E7%94%A8%E5%B1%82%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92.png)

### 数据包传输过程
![image](https://github.com/hl845740757/fastjgame-net/blob/master/src/doc/%E6%95%B0%E6%8D%AE%E5%8C%85%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png)

### rpc注解处理器
    请查看项目总目录下的readMe。

### example下的测试用例
   Rpc测试用例： 有**ExampleRpcService** 和 **ExampleRpcClientLoop**。
   贴近底层的示例：有**EchoServerLoop**和**EchoLCientLoop****，可以直接启动。 
### Bugs
   码多必失，如果发现bug，欢迎提出。
