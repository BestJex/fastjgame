协议约定：
公共部分：
 int  4字节      frameLength       有效帧长度(不包含自身)
 long 8字节      checkSum          消息的内容的校验和(不包含第一个字段和自身)
 byte 1字节      pkgType           协议的类型(每种协议一个固定值)

1. 请求建立连接(或重连)               [传输控制协议]
 long  8字节     clientGuid        客户端唯一标识(发起方guid)
 int   4字节     verifyingTimes    这是客户端第几次发起连接请求：用于识别最新请求和客户端追踪结果
 int   4字节     verifiedTimes     客户端验证成功次数(判断是重连还是首次建立连接)

 long  8字节     initSequence      客户端的初始sequence - 用于首次建立连接时
 long  8字节     ack               客户端期望的下一个消息号 - 用于重连时
 byte  1字节     close             是否是断开连接消息

 bytes 指定      sessionId         要建立的session的唯一标识(放最后可以省去额外的长度字段)

2. 建立连接应答                      [传输控制协议]
 byte  1字节     success           是否允许建立连接
 int   4字节     verifyingTimes    这是客户端第几次发起的连接请求
 int   4字节     verifiedTimes     客户端验证成功次数

 long  8字节     initSequence      服务器的初始sequence - 用于首次建立连接时
 long  8字节     ack               服务器期望的下一个消息号(首次建立连接时就是正式的ack了)
 byte  1字节     close             是否是断开连接消息

3. 心跳协议 - ping/pong            [传输控制协议] （请注意：网络层心跳不能代替逻辑层心跳）
 long  8字节      ack              我期望的下一个消息号(捎带确认的ack)
 byte  1字节      pingOrPong       ping还是pong

4. Rpc请求包                      （用户数据）
 long  8字节     sequence         这是我发送的第几个包/帧。
 long  8字节     ack              我期望的下一个消息号(捎带确认的ack)

 long  8字节     requestGuid      请求id
 byte  1字节     sync             是否是同步rpc调用
 bytes 字节数组   bytes            请求的内容

5. Rpc响应包                     （用户数据）
 long  8字节     sequence         这是我发送的第几个包/帧
 long  8字节     ack              我期望的下一个消息号(捎带确认的ack)

 long  8字节     requestGuid      请求id
 int   4字节     resultCode       错误码
 bytes 字节数组   bytes            响应结果

6. 单向消息包                      （用户数据）
 long  8字节     sequence         这是我发送的第几个包/帧。
 long  8字节     ack              我期望的下一个消息号(捎带确认的ack)

 bytes 字节数组   bytes            消息的内容

本质上讲，协议只有4种：
1. 建立连接请求
2. 建立连接应答
3. 心跳
4. 正式消息（rpc请求、rpc响应、单向消息都是它的细分类型而已） - 甚至说心跳也可以算做正式消息的一种。
可参考tcp通信进行理解，感觉也很像websocket。

Q: 为何是两次握手？而没和TCP一样三次握手？
A: 因为我们是基于TCP的，认为底层已经提供了连接的可靠性。

Q: 其它消息都有ack和sequence的情况下为什么还需要单独的心跳包？
A: 1.采用捎带确认基于这样的假设：请求一般会存在一个响应，且双方总是有消息要发给另一方，而且间隔不会太长,。
2.但请求可能没有响应信息,在长时间没有新的消息通信情况下，需要有机制对前面的消息进行确认。
3.此外，用于避免双方消息队列缓存过多(尤其是要降低服务器缓存压力)
4.保持链接的活性

之前总是想把玩家的消息也放在这里，其实是分层没搞清楚。
服务器之间的协议是下层的协议，玩家与网关之间的协议是上层协议，就像 http与tcp， http运行在tcp协议之上。
而我企图将它们放在一块，想着在这里加点什么，那里加点什么，这是不对的。
之前画的数据传输过程是对的，但是实现的时候有点跑偏了。

Q: 为何删除了断开连接协议？
A: 应用层有更好的方式通知对方关闭。