协议约定：
公共部分：
 int  4字节      frameLength       有效帧长度(不包含自身)
 long 8字节      checkSum          消息的内容的校验和(不包含第一个字段和自身)
 byte 1字节      pkgType           协议的类型(每种协议一个固定值)

1. 请求建立连接(或重连) -  服务器之间不需要token
 short 2字节     sessionIdLength   sessionId占用的字节数
 bytes 指定      sessionId         要建立的session的唯一标识
 long  8字节     clientGuid        用户唯一标识(发起方guid)
 int   4字节     verifyingTimes    这是客户端第几次发起连接请求：用于识别最新请求和客户端追踪结果
 long  8字节     ack               客户端期望的下一个消息号(捎带确认的ack)
 bytes 字节数组   extension         用于扩展的信息

2. 建立连接应答
 byte  1字节     success           是否允许建立连接
 int   4字节     verifyingTimes    这是客户端第几次发起的连接请求
 long  8字节     ack               服务器期望的下一个消息号

3、4 心跳协议 - ping/pong
 long  8字节      sequence         这是我发送的第几个包/帧。
 long  8字节      ack              我期望的下一个消息号(捎带确认的ack)

5. Rpc请求包（正式消息）
 long  8字节     sequence         这是我发送的第几个包/帧。
 long  8字节     ack              我期望的下一个消息号(捎带确认的ack)

 long  8字节     requestGuid      请求id
 byte  1字节     sync             是否是同步rpc调用
 bytes 字节数组   bytes            请求的内容

6. Rpc响应包（正式消息）
 long  8字节     sequence         这是我发送的第几个包/帧
 long  8字节     ack              我期望的下一个消息号(捎带确认的ack)

 long  8字节     requestGuid      请求id
 int   4字节     resultCode       错误码
 bytes 字节数组   bytes            响应结果

7. 单向消息包（正式消息）
 long  8字节     sequence         这是我发送的第几个包/帧。
 long  8字节     ack              我期望的下一个消息号(捎带确认的ack)

 bytes 字节数组   bytes            消息的内容

本质上讲，协议只有4种：
1. 建立连接请求
2. 建立连接应答
3. 心跳
4. 正式消息（rpc请求、rpc响应、单向消息都是它的细分类型而已） - 甚至说心跳也可以算做正式消息的一种。
可参考tcp通信进行理解，感觉也很像websocket。

其它消息都有ack和sequence的情况下为什么还需要单独的心跳包？
1.采用捎带确认基于这样的假设：请求一般会存在一个响应，且双方总是有消息要发给另一方，而且间隔不会太长,。
2.但请求可能没有响应信息,在长时间没有新的消息通信情况下，需要有机制对前面的消息进行确认。
3.此外，用于避免双方消息队列缓存过多(尤其是要降低服务器缓存压力)
4.保持链接的活性

之前总是想把玩家的消息也放在这里，其实是分层没搞清楚。
服务器之间的协议是下层的协议，玩家与网关之间的协议是上层协议，就像 http与tcp， http运行在tcp协议之上。
而我企图将它们放在一块，想着在这里加点什么，那里加点什么，这是不对的。
之前画的数据传输过程是对的，但是实现的时候有点跑偏了。