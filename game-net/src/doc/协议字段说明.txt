带有ack 和 sequence的就完全是网关服的逻辑了。
正常服务器与服务器之间就可以不需要这些了，如果需要的话，加个组件就可以。
网络本身就是个数据流 - 要演化为对流操作。


协议约定：
公共部分：
 int  4字节      frameLength       有效帧长度(不包含自身)
 long 8字节      checkSum          消息的内容的校验和(不包含第一个字段和自身)
 byte 1字节      pkgType           协议的类型(每种协议一个固定值)

1. 请求建立连接(重连)
 long  8字节     clientGuid        客户端唯一标识，用于关联会话
 int   4字节     clientRole        客户端类型
 int   4字节     verifyingTimes    这是客户端第几次发起连接请求：用于识别最新请求和客户端追踪结果
 long  8字节     ack               客户端收到的最大消息号(捎带确认的ack)

2. 建立连接响应
 int   4字节     verifyingTimes    这是客户端第几次发起的连接请求
 byte  1字节     success           token验证结果(成功为 1,失败为 0)

 long  8字节     ack               服务器收到的最大消息号

3. Rpc请求包(服务器之间)
 long  8字节     ack              我收到的最大消息号(捎带确认的ack)
 long  8字节     sequence         这是我发送的第几个包/帧。

 long  8字节     requestGuid      请求id
 byte  1字节     sync             是否是同步rpc调用
 bytes 字节数组   requestBytes     请求的内容，用户自定义解析

4. Rpc响应包(服务器之间)
 long  8字节     ack              我收到的最大消息号(捎带确认的ack)
 long  8字节     sequence         这是我发送的第几个包/帧

 long  8字节     requestGuid      请求id
 int   4字节     resultCode       错误码
 bytes 字节数组   responseBytes    响应结果，用户自定义解析

5. 单向消息包(服务器之间)
 long  8字节     ack              我收到的最大消息号(捎带确认的ack)
 long  8字节     sequence         这是我发送的第几个包/帧。

 bytes 字节数组   messageBytes     消息的内容，用户自定义解析

6、7 客户端ack-ping消息 和 服务器返回的ack-pong消息 同结构 定长消息
 long  8字节      ack              我收到的最大消息号(捎带确认的ack)
 long  8字节      sequence         这是我发送的第几个包/帧。

8. 主动断开连接包(没有内容)

9. 重定向(让网关断开当前连接，连接另一个服务器)
 long 8字节       targetGuid      要连接的另一个服务器guid


在3、4、5都有捎带确认的ack情况下为什么还需要6和7 （单独的心跳包）？
1.采用捎带确认基于这样的假设：请求一般会存在一个响应，且双方总是有消息要发给另一方，而且间隔不会太长,。
2.但请求可能没有响应信息,在长时间没有新的消息通信情况下，需要有机制对前面的消息进行确认。
3.此外，用于避免双方消息队列缓存过多(尤其是要降低服务器缓存压力)
4.保持链接的活性