#### 历史重要更新

#### 场景服架构调整 2019年10月31日
删除纯粹的单服场景服，即每个场景服即提供单服玩法，也提供跨服玩法。该架构有以下优势：  
1. 可以实现更好的负载均衡和高可用。  
2. 可以支持更多的跨服互动。  
PS: 有点伪世界服架构的感觉。

#### 使用EventBus重写了NetEventLoop和NetEventLoop中的接口2019年10月27日
使用EventBus有好有坏，我也是纠结了很久才决定改造的。  
EventBus对于解耦和接口演进很有用，对于性能肯定是会拖慢一点的，另外也会造成可读性的下降。  
Q: 有时候做选择的时候会纠结，为什么纠结呢？  
A: 当不太清楚即将的改动对性能到底有多大影响时就会纠结。。。

#### 重新实现了消息确认机制，支持限流 2019/10/18
重新实现了消息确认机制，不过需要翻译**OuterConnectorHandler**为客户端对应的语言。  
新版本特性：
1. 使用了累积确认机制，可以更快的对数据包进行确认。  
2. 使用了漏桶算法，可以有效的控制发包速率，消息重发也更加安全(有效控制了重发包时的数量)。  

Q: 为什么需要消息确认机制？  
A: 消息确认机制主要针对手机用户的。移动端网络不稳定，很容易产生丢包，socket断开的情况，如果socket断开就使得玩家必须重新登录(包括快速登录)
这个体验是非常差的。消息确认机制可以使得玩家感觉只是产生了延迟。

#### 单向消息/Rpc支持转发，中间节点消除序列化反序列化操作 2019年10月11日
请注意查看**LazySerializable**和PreDeserializable**注解。  
Q: 它主要解决什么问题？  
A: 逻辑服务器通过网关向玩家发送数据，玩家向逻辑服务器发送数据时，在网关服消除冗余的编解码操作。

#### 恢复NetEventLoop多线程模型 2019年10月05日 - 真香
通过sessionId实现粘性session，使得同一个sessionId的数据总是由同一个NetEventLoop来处理，从而保证数据安全性，即使更换channel，仍然支持消息确认机制。

#### 通过SessionPipeline提供功能插拔特性 2019年10月02日
1. 之前的SessionManager代码组织较为混乱，扩展功能较为困难，一直在想办法解决这个问题，这版本引入了类似Netty的ChannelPipeline的SessionPipeline。
通过handler的方式实现插拔功能，以消除重复代码和提升扩展性。  
如：是否使用消息确认机制通过增删handler来实现，内网通信可以不开启，这样内网通信传输的数据量就会减少许多，走到的代码也会少很多。   
又如：服务器与玩家之间是没有rpc的，因此与玩家的session之间也不会有rpc相关的逻辑。  
当然，这是有代价的，代价就是JVM内部传输数据速度变慢，因为有大量的空方法需要执行和冗余判断 - 这些在JVM内部通信之间占的比重还挺大。  
2. **该版本需要重新生成注解处理器**（文件重新归档导致）。
3. 还有很多尚未完成的地方，只是都可以重新运行起来了，还需要继续迭代。

#### 正确的实现DisruptorEventLoop 2019年9月17日
之前实现的Disruptor跑偏了，这两日突然想明白了，进行了正确的实现，相对于**SingleThreadEventLoop**，内存利用率更高，性能也更好，对于追求极致性能的EventLoop提供了很好的框架。  
顺便基于DisruptorEventLoop重写了GameEventLoop。  
如果你想要学习**Disruptor**，那么推荐你看我详细注释过的源码[disruptor-translation](https://github.com/hl845740757/disruptor-translation)  
如果你想学习**Netty**的线程模型，你可以看看我注释过的源码[netty-translation](https://github.com/hl845740757/netty-translation)，netty并没有全部注释，不过并发包是基本是完整注释的。  

#### 修改sync语义 2019年9月13日
同步rpc调用不再插队，而是刷新缓冲区，和其它消息之间也满足先发的先到，后发的后到。

#### LocalSession 2019年9月10日
为JVM内部线程提供session支持，JVM内通信和跨进程之间的通信有相同的API。你可以通过**NetContext**轻松的连接到另一个线程，其通信开销远远小于socket。  
**LocalSessionExample**是一个测试用例。

#### 线程模型调整 2019年9月06日
一个GameEventLoop只承载单个World，具有更简单的编程模型，且更加安全。

#### 注解处理器优化 2019-08-26
注解处理器不再依赖utils和net模块，而是utils依赖auto模块，这样utils和net模块也可以使用自己定义的注解了。

#### EventBus 2019-08-24
1. 在utils包下有一套基础的EventBus实现。
2. 订阅方法代码自动生成。
3. 在example目录下同样提供了一个测试用例，编译后可运行。

#### Rpc优化 2019-08-21
1. Rpc调用更加标准化。
2. 编解码更快，功能支持更强，请查看**SerializableClass**和**SerializableField**注解。
3. RpcService代码自动生成，你必须将game-auto打为jar包才可以使用代码生成工具(注解处理器必须是jar包形式)，请确保所有模块都启用了注解处理器。
4. 在net模块下，example下有几个测试用例，其中： **ExampleRpcClientLoop**是一个Rpc客户端，**ExampleRpcService**是一个Rpc服务，编译后可直接运行。
5. 还有一些别的测试用例，并没有使用自动生成的代码，用法很原始，更贴近底层。